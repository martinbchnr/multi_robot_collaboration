#include <std_msgs/Bool.h> 
#include "./../include/local_manager/local_manager.hpp"

#include <sstream>
#include <iostream>
#include <cfloat>
#include <math.h> 

// CONSTRUCTOR
LocalManager::LocalManager()
{

    ros::NodeHandle private_nh("~");
    node_name_ = ros::this_node::getName();
    
    // RECEIVE COORDINATE FRAME ACCORDING TO WHICH ALL GOALS REFERENCE TO
    private_nh.param<std::string>("goal_frame", goal_frame_, "map");
    ROS_INFO("[%s]: The 'goal_frame' parameter specified the frame for the goals as: '%s'.", node_name_.c_str(),goal_frame_.c_str());
    
    // INITIATE MOVEBASE-CLIENT PROTOCOL
    action_client_ = new MoveBaseClient("move_base", true);
    while (!action_client_->waitForServer(ros::Duration(5.0)))
    {
        ROS_INFO("[%s]: Waiting for the move_base action server to come up.", node_name_.c_str()); 
    }
    // INITATE END STATUS PUBLISHER
    end_status_publisher_ = private_nh.advertise<std_msgs::Bool >("execution_ended", 1, true);
}

// DESTRUCTOR
LocalManager::~LocalManager()
{
    delete action_client_;
}



// SUBSCRIBING

void LocalManager::SubscribeToTopics()
{
  // SUBSCRIBE TO LOCAL TRAVERSE FOR EACH ROBOT
  // The local_traverse is generated by the local_path_planner and represents the local path to be taken
  // on the grid between the current robot position and the next global goal.

  if (!local_traverse_topic_.empty())
  {
      ROS_INFO("[%s]: Subscribing to topic '%s'", node_name_.c_str(), local_traverse_topic_.c_str());
      local_traverse_sub = node_.subscribe(local_traverse_topic_, 1, &LocalManager::localTraverseCallback, this);
  }
  else
  {
      ROS_INFO("[%s]: Topic '%s' is Empty", node_name_.c_str(), "local_traverse");
  }

  // SUBSCRIBE TO AMCL ROBOT POSE (NATURALLY, PER ROBOT)

  if (!robot_pose_topic_.empty())
  {
      ROS_INFO("[%s]: Subscribing to topic '%s'", node_name_.c_str(), robot_pose_topic_.c_str());
      robot_pose_sub = node_.subscribe(robot_pose_topic_, 1, &LocalManager::robotPoseCallback, this);
  }
  else
  {
      ROS_INFO("[%s]: Topic '%s' is Empty", node_name_.c_str(), "amcl_pose");
  }

  // SUBSCRIBE TO MOVE_BASE ACTION RESULT FOR EACH ROBOT
  // Separately, to the MoveBaseClient-protocol we subscribe to the move_base/result-topic because during extensive 
  // runtime testing and bugfixing it proved to be more reliable than the protocol itself.

  if (!move_base_result_topic_.empty())
  {
      ROS_INFO("[%s]: Subscribing to topic '%s'", node_name_.c_str(), move_base_result_topic_.c_str());
      move_base_result_sub = node_.subscribe(move_base_result_topic_, 1, &LocalManager::moveBaseResultCallback, this);
  }
  else
  {
      ROS_INFO("[%s]: Topic '%s' is Empty", node_name_.c_str(), "move_base/result");
  }


  // SUBSCRIBE TO PSEUDO GOAL TRAVERSE PER ROBOT
  // This represents the exploration mode where the dirt_generater publishes virtual pseudo goals that need to be 
  // traversed by the robots in order to ensure maximum exploration when no global goals are available.
  
  // This mode additionally enables better load balancing because many goals are often rather assigned to one robot 
  // and none to the other one, e.g. in situations when both robots are close to each other and are positioned in 
  // one corner of the environment.
  // In this case, both robots still move and incrementally the robot without any goals will see more of the grid
  // and will subsequently get closer to goals that are then assigned to it.

  if (!pseudo_goal_list_topic_.empty())
  {
      ROS_INFO("[%s]: Subscribing to topic '%s'", node_name_.c_str(), pseudo_goal_list_topic_.c_str());
      pseudo_goals_sub = node_.subscribe(pseudo_goal_list_topic_, 1, &LocalManager::pseudoGoalListCallback, this);
  }
  else
  {
      ROS_INFO("[%s]: Topic '%s' is Empty", node_name_.c_str(), pseudo_goal_list_topic_.c_str());
  }
}

// PUBLISHING

// PUBLISH SUCCEEDED LOCAL GOAL TO THE GLOBAL_MANAGER
// When the local_manager publishes the goal it is subscribed by the global_manager that then checks if this
// local_goal is identical with the currently pursued global goal (as computed by the task_allocator)

void LocalManager::PublishSucceededLocalGoal()
{
    ROS_INFO("[%s]: Publishing to topic '%s'", node_name_.c_str(), succeeded_local_goal_topic_.c_str());
    succeeded_local_goal_pub = node_.advertise<goal_list::GoalObject>("local_manager_goal_return", 100);
}



void LocalManager::pursueLocalGoals() {

  // HEADER DESCRIPTION
  // With the pursueLocalGoals-function the repeated but constant behavior of the system is represented.
  // It is run per spin and activates the system to follow the currently available and most up-to-date
  // local_traverse information. Thus it really ensures our real time capability.


    // First check if we have local goals left in the fifo
    if(!local_fifo.empty()) {

      // Construct local variable used within pursueLocalGoals()
      move_base_msgs::MoveBaseGoal local_goal;

      // Receive next element from fio
      std::pair<double,double> new_goal = local_fifo.front();
    
      double next_goal_x = std::get<0>(new_goal);
      double next_goal_y = std::get<1>(new_goal);

      // FIRST ORDER TAYLOR EXPANSION FEATURE
      // By evaluating the position of the goal after current goal we can
      // the robot with an orientation information when arriving at the 
      // current goal. In this fashion we can decrease the time spent at 
      // each particular goal location because the robot automatically 
      // heads towards the next goal to come.

      geometry_msgs::Quaternion goal_quaternion_msg;
      double goal_yaw;

      // check if there are at least two goals left to compute the taylor term
      // you will always need two points 
      if(local_fifo.size() > 1) {
        
        // access goal after current goal
        std::pair<double,double> subsequent_goal = local_fifo.at(1);
  
        double subsequent_goal_x = std::get<0>(subsequent_goal);
        double subsequent_goal_y = std::get<1>(subsequent_goal);
        
        // Compute the goal-to-goal distance per coordinate
        double delta_x = subsequent_goal_x - next_goal_x;
        double delta_y = subsequent_goal_y - next_goal_y;

        // filter out singularity of atan
        if(delta_x<=0.05 && delta_x>=-0.05) {
          goal_yaw = 0.0;
        }
        else {
          // compute direction angle given the ROS REP 105 standard 
          goal_yaw = atan (delta_y/delta_x);
        }

        // generate new quaternion from current yaw
        tf::Quaternion quaternion;
        quaternion.setRPY(0.0, 0.0, goal_yaw);
        // transform to tf-message
        tf::quaternionTFToMsg(quaternion, goal_quaternion_msg);

        // for debugging
        //ROS_INFO("[%s]: FIFO>1: quaternion %f,%f,%f,%f", node_name_.c_str(), goal_quaternion_msg.x, goal_quaternion_msg.y, goal_quaternion_msg.z, goal_quaternion_msg.w);

      }
      else {
        // fifo does only contain goal as last element
        // this quaternion does not specify a distinct direction
        goal_quaternion_msg.w = 1.0;
        goal_quaternion_msg.x = 0.0;
        goal_quaternion_msg.y = 0.0;
        goal_quaternion_msg.z = 0.0;
        
        // Debugging
        //ROS_INFO("[%s]: FIFO<=1: quaternion %f,%f,%f,%f", node_name_.c_str(), goal_quaternion_msg.x, goal_quaternion_msg.y, goal_quaternion_msg.z, goal_quaternion_msg.w);
      }

      // NOW PURSUE THE NEXT GOAL FROM THE FIFO
      local_goal.target_pose.header.frame_id = goal_frame_;
      local_goal.target_pose.header.stamp = ros::Time::now();
      local_goal.target_pose.pose.position.x = std::get<0>(new_goal);
      local_goal.target_pose.pose.position.y = std::get<1>(new_goal);
      local_goal.target_pose.pose.position.z = 0.0;
      // Use previously created goal quaternion
      local_goal.target_pose.pose.orientation = goal_quaternion_msg;

      std::string goal_description = "["+std::to_string(local_goal.target_pose.pose.position.x)+","+std::to_string(local_goal.target_pose.pose.position.y)+"]";
      ROS_INFO("[%s]: pursueLocalGoals(): %s", node_name_.c_str(), goal_description.c_str());
      
      // Inform the move_base of the goal to be pursued currently
      action_client_->sendGoal(local_goal);  
    } 
    else {

      // EXPLORATION MODE
      ROS_INFO("[%s]: pursueLocalGoals(): FIFO EMPTY -> SWITCH TO EXPL. MODE (PSEUDO)", node_name_.c_str());

      // IF THE FIFO DOES NOT CONTAIN ANY MORE LOCAL GOALS 
      // WE SWITCH TO OUR EXPLORATION MODE THAT DIRECTLY RECEIVES GOALS 
      // FROM THE DIRT GENERATOR
      // This case represents that there are no global goals left
      // since the local_path_planner does not compute a plan

      // The pseudo fifo is an ordered list of pseudo goals that
      // steers the robot across the environment in order to maximize
      // exploration (it just detects new goals on its way)

      // Check if pseudo fifo contains any virtual goals
      if(!pseudo_fifo.empty())
      {
      // new locally defined movebasegoal
      move_base_msgs::MoveBaseGoal pseudo_goal;

      pseudo_goal.target_pose.header.frame_id = goal_frame_;
      pseudo_goal.target_pose.header.stamp = ros::Time::now();
      // access the latest pseudo goal
      pseudo_goal.target_pose.pose.position.x = std::get<0>(latest_pseudo_goal);
      pseudo_goal.target_pose.pose.position.y = std::get<1>(latest_pseudo_goal);
      // provide undefined orientation
      pseudo_goal.target_pose.pose.orientation.w = 1.0;
      pseudo_goal.target_pose.pose.orientation.x = 0.0;
      pseudo_goal.target_pose.pose.orientation.y = 0.0;
      pseudo_goal.target_pose.pose.orientation.z = 0.0;

      // provide move_base with pseudo goal
      action_client_->sendGoal(pseudo_goal);
      }
      else{
        // NO PSEUDO-GOALS TO PURSUE
        ROS_INFO("[%s]: NO PSEUDO GOALS LEFT", node_name_.c_str());
      }

    }


}


void LocalManager::HandleMoveBaseReaction() {

  // HEADER DESCRIPTION
  // The HandleMoveBaseReaction() method is taking care of processing
  // of callbacks due to the current execution status
  //
  // We define a strategy what should be done under which circumstances.
  // After exhaustive trial-and-error and becoming familiar with the move_base
  // communication we have come up with the following state-to-action principle.
  //
  // Note that the move_base-topics sometimes contain information that
  // by no means is applicable to the current situation. E.g. sometimes it is
  // published that a particular goal has been reached although it actually was not.
  // Because of that, we have augmented the topic checks with positional
  // checks (utilizing the acml_pose-topic) to ensure a robust behavior even 
  // when the move_base exhibits irrational behavior.
  //
  // actionlib-protocol: http://wiki.ros.org/actionlib/DetailedDescription

  /*
  ACTION HANDLING STRATEGY
  9 LOST --> next_goal
  8 RECALLED --> next_goal
  7 RECALLING --> next goal
  6 PREEMPTING --> stick to goal
  5 REJECTED --> next goal
  4 ABORTED --> next goal
  3 SUCCEEDED --> next goal
  2 PREEMPTED --> next goal
  1 ACTIVE --> do nothing
  0 PENDING --> do nothing
  */  

  // access latest move_base/result topic information
  int move_status = move_base_result.status.status; 


  if(move_status==0 || move_status==1) {

    /*
    uint8 PENDING         = 0   # The goal has yet to be processed by the action server
    >>>>>>> strategy: stick to goal / do nothing

    uint8 ACTIVE          = 1   # The goal is currently being processed by the action server
    >>>>>>> strategy: stick to goal / do nothing
    */

    // DO NOTHING
  }

  
  if(move_status == 2) {

    /*
    //std::pair<double,double> succeeded_goal_temp = local_fifo.front();
    // previous goal successfully reached, get next element from list
    ROS_INFO("[%s]: REACHED CANCELLED GOAL UNINTENDEDLY", node_name_.c_str());


    // Get and publish the unintendedly succeeded_goal
    //succeeded_goal.pose.position.x = std::get<0>(succeeded_goal_temp);
    //succeeded_goal.pose.position.y = std::get<1>(succeeded_goal_temp);
    //succeeded_goal_pub.publish(succeeded_goal);

    // Delete succeeded_goal from local_fifo
    local_fifo.pop();
    ROS_INFO("[%s]: PUBLISHED + DELETED SUCCEEDED GOAL", node_name_.c_str());
    //action_client_->cancelAllGoals();
    std::pair<double,double> new_goal = local_fifo.front();

    move_base_msgs::MoveBaseGoal goal;
    goal.target_pose.header.frame_id = goal_frame_;
    goal.target_pose.header.stamp = ros::Time::now();
    goal.target_pose.pose.position.x = std::get<0>(new_goal);
    goal.target_pose.pose.position.y = std::get<1>(new_goal);
    goal.target_pose.pose.position.z = 0.0;
    goal.target_pose.pose.orientation.w = 1.0;
    goal.target_pose.pose.orientation.x = 0.0;
    goal.target_pose.pose.orientation.y = 0.0;
    goal.target_pose.pose.orientation.z = 0.0;

    action_client_->sendGoal(goal);
    
    ROS_INFO("[%s]: SENT GOAL -> [%f, %f]", node_name_.c_str(), std::get<0>(new_goal), std::get<1>(new_goal));
    */
  }


  if(move_status ==3) {

    /*
    uint8 SUCCEEDED       = 3   # The goal was achieved successfully by the action server (Terminal State)
    >>>>>>> strategy: next goal
    */

    // CHECK FOR STANDARD GOALS FIRST

    // access current goal
    std::pair<double,double> succeeded_local_goal_temp = local_fifo.front();
    // compute the coordinate-wise deltas between goal and current amcl pose
    double local_goal_x = std::get<0>(succeeded_local_goal_temp); 
    double local_goal_y = std::get<1>(succeeded_local_goal_temp);
    double local_x_diff = abs(local_goal_x - robot_pos_x);
    //ROS_INFO("[%s]: X-DIFF %f", node_name_.c_str(), local_x_diff);
    double local_y_diff = abs(local_goal_y - robot_pos_y);
    //ROS_INFO("[%s]: Y-DIFF %f", node_name_.c_str(), local_y_diff);

    // check if local fifo is not empty and whether the positional constraints are fulfilled
    if(!local_fifo.empty() && local_x_diff <= DIRT_POS_TOLERANCE && local_y_diff <= DIRT_POS_TOLERANCE) {

      ROS_INFO("[%s]: REACHED GOAL SUCCESSFULLY AT: [%f,%f]", node_name_.c_str(), std::get<0>(succeeded_local_goal_temp),std::get<1>(succeeded_local_goal_temp));

      // Get and publish the succeeded_goal
      succeeded_local_goal.pose.position.x = std::get<0>(succeeded_local_goal_temp);
      succeeded_local_goal.pose.position.y = std::get<1>(succeeded_local_goal_temp);
      succeeded_local_goal_pub.publish(succeeded_local_goal);

      // Delete succeeded_goal from local_fifo
      local_fifo.pop_front();
      ROS_INFO("[%s]: PUBLISHED + DELETED SUCCEEDED GOAL", node_name_.c_str());

    }

    // THEN, CHECK FOR PSEUDO GOALS
    // compute the locational delta between pseudo goal and robot position
    double pseudo_goal_x = std::get<0>(latest_pseudo_goal); 
    double pseudo_goal_y = std::get<1>(latest_pseudo_goal);
    double pseudo_x_diff = abs(pseudo_goal_x - robot_pos_x);
    //ROS_INFO("[%s]: X-DIFF %f", node_name_.c_str(), local_x_diff);
    double pseudo_y_diff = abs(pseudo_goal_y - robot_pos_y);
    //ROS_INFO("[%s]: Y-DIFF %f", node_name_.c_str(), local_y_diff);


    // check if pseudo fifo is not empty and whether the positional constraints are fulfilled
    if(!pseudo_fifo.empty() && pseudo_x_diff <= DIRT_POS_TOLERANCE && pseudo_y_diff <= DIRT_POS_TOLERANCE){

      //ROS_INFO("[%s]: REACHED PSEUDO GOAL SUCCESSFULLY AT: [%f,%f]", node_name_.c_str(), std::get<0>(latest_pseudo_goal),std::get<1>(latest_pseudo_goal));

      // check whether the reached goal is still identical to the first pseudo goal in the pseudo fifo
      if(pseudo_goal_x==std::get<0>(latest_pseudo_goal_new) && pseudo_goal_y==std::get<1>(latest_pseudo_goal_new))
      {
        // PSEUDO HAS NOT UPDATED YET 
        // POP FIRST ELEMENT OF PSEUDO-FIFO = latest_pseudo_goal_new = latest_pseudo_goal
        pseudo_fifo.pop_front();
        latest_pseudo_goal = pseudo_fifo.front();
      }
      else 
      {
        // PSEUDO FIFO HAS CHANGED IN THE MEANWHILE
        // DO NOT POP FIRST ELEMENT OF PSEUDO -> RATHER TAKE IT AS NEXT latest GOAL
        latest_pseudo_goal = pseudo_fifo.front();
        //ROS_INFO("[%s]: DIFF. PSEUDO FIFO -> NEXT EXPL GOAL: [%f,%f]", node_name_.c_str(), std::get<0>(latest_pseudo_goal),std::get<1>(latest_pseudo_goal));
      }
      
    }

    // check if local_fifo still contains elements
    if(!local_fifo.empty()) {

      // access next goal
      std::pair<double,double> next_local_goal = local_fifo.front();
    
      double next_goal_x = std::get<0>(next_local_goal);
      double next_goal_y = std::get<1>(next_local_goal);


      geometry_msgs::Quaternion goal_quaternion_msg;
      double goal_yaw;

      // check if there is at least one goal left after the current one
      if(local_fifo.size() > 1) {
        
        // access goal after current goal
        std::pair<double,double> subsequent_goal = local_fifo.at(1);
  
        double subsequent_goal_x = std::get<0>(subsequent_goal);
        double subsequent_goal_y = std::get<1>(subsequent_goal);
        
        // Compute the goal-to-goal geometric delta
        double delta_x = subsequent_goal_x - next_goal_x;
        double delta_y = subsequent_goal_y - next_goal_y;

        // compute direction angle given the ROS REP 105 standard 
        if(delta_x<=0.05 && delta_x>=-0.05) {
          goal_yaw = 0.0;
          //ROS_INFO("[%s]: YAW %f", node_name_.c_str(), goal_yaw);
        } 
        else {
          goal_yaw = atan (delta_y/delta_x);
          //ROS_INFO("[%s]: YAW %f", node_name_.c_str(), goal_yaw);
        }

        // initialize quaternion from generated yaw angle
        goal_quaternion_msg = tf::createQuaternionMsgFromYaw(goal_yaw);

        // previously used method left for reference:
        //tf::Quaternion quaternion;
        //quaternion.setRPY(0.0, 0.0, tfScalar(goal_yaw));
        //tf::quaternionTFToMsg(quaternion, goal_quaternion_msg);
        
        //ROS_INFO("[%s]: FIFO>1: quaternion %f,%f,%f,%f", node_name_.c_str(), goal_quaternion_msg.x, goal_quaternion_msg.y, goal_quaternion_msg.z, goal_quaternion_msg.w);

      }
      else {
        // if only one goal is left
        goal_quaternion_msg.w = 1.0;
        goal_quaternion_msg.x = 0.0;
        goal_quaternion_msg.y = 0.0;
        goal_quaternion_msg.z = 0.0;
        
        //ROS_INFO("[%s]: FIFO<=1: quaternion %f,%f,%f,%f", node_name_.c_str(), goal_quaternion_msg.x, goal_quaternion_msg.y, goal_quaternion_msg.z, goal_quaternion_msg.w);
      }
      
      // New movebasegoal instance fed with position + orientation computed as above
      move_base_msgs::MoveBaseGoal local_goal;
      local_goal.target_pose.header.frame_id = goal_frame_;
      local_goal.target_pose.header.stamp = ros::Time::now();
      local_goal.target_pose.pose.position.x = std::get<0>(next_local_goal);
      local_goal.target_pose.pose.position.y = std::get<1>(next_local_goal);
      local_goal.target_pose.pose.position.z = 0.0;
      local_goal.target_pose.pose.orientation = goal_quaternion_msg;
  
    // provide move_base with current goal
    action_client_->sendGoal(local_goal);
    ROS_INFO("[%s]: SENT GOAL -> [%f, %f]", node_name_.c_str(), std::get<0>(next_local_goal), std::get<1>(next_local_goal));
    }
    else {
      ROS_INFO("[%s]: pursueGoals(): FIFO EMPTY -> SWITCH TO EXPL. MODE (PSEUDO)", node_name_.c_str());
      // GO INTO EXPLORATION MODE


      // IF THE FIFO DOES NOT CONTAIN ANY MORE LOCAL GOALS 
      // WE SWITCH TO OUR EXPLORATION MODE THAT DIRECTLY RECEIVES GOALS 
      // FROM THE DIRT GENERATOR
      // This case represents that there are no global goals left
      // since the local_path_planner does not compute a plan

      // The pseudo fifo is an ordered list of pseudo goals that
      // steers the robot across the environment in order to maximize
      // exploration (it just detects new goals on its way)

      // Check if pseudo fifo contains any virtual goals

      // still check if pseudo fifo has elements left
      if(!pseudo_fifo.empty())
      {
      move_base_msgs::MoveBaseGoal pseudo_goal;

      pseudo_goal.target_pose.header.frame_id = goal_frame_;
      pseudo_goal.target_pose.header.stamp = ros::Time::now();
      pseudo_goal.target_pose.pose.position.x = std::get<0>(latest_pseudo_goal);
      pseudo_goal.target_pose.pose.position.y = std::get<1>(latest_pseudo_goal);
      pseudo_goal.target_pose.pose.orientation.w = 1.0;
      pseudo_goal.target_pose.pose.orientation.x = 0.0;
      pseudo_goal.target_pose.pose.orientation.y = 0.0;
      pseudo_goal.target_pose.pose.orientation.z = 0.0;
  
      // provide move_base with goal
      action_client_->sendGoal(pseudo_goal);
      }
      else{
        // NO PSEUDO-GOALS TO PURSUE
        ROS_INFO("[%s]: NO PSEUDO GOALS LEFT", node_name_.c_str());
      }

    }
  } 
  

  



  
  if(move_status==4 || move_status==5) {

    /*
    PROTOCOL DESCRIPTION

    uint8 ABORTED         = 4   # The goal was aborted during execution by the action server due
                                #    to some failure (Terminal State)
    //>>>>>>> strategy: next goal

    uint8 REJECTED        = 5   # The goal was rejected by the action server without being processed,
                                #    because the goal was unattainable or invalid (Terminal State)
    >>>>>>> strategy: next goal
    
    action_client_->cancelAllGoals();
    std::pair<double,double> succeeded_goal_temp = local_fifo.front();
    ROS_INFO("[%s]: ABORTED/REJECTED GOAL AT: [%f,%f]", node_name_.c_str(), std::get<0>(succeeded_goal_temp),std::get<1>(succeeded_goal_temp));

    // Get and publish the succeeded_goal
    succeeded_goal.pose.position.x = std::get<0>(succeeded_goal_temp);
    succeeded_goal.pose.position.y = std::get<1>(succeeded_goal_temp);
    succeeded_goal_pub.publish(succeeded_goal);

    // Delete succeeded_goal from local_fifo
    local_fifo.pop();
    ROS_INFO("[%s]: PUBLISHED + DELETED SUCCEEDED GOAL", node_name_.c_str());

    std::pair<double,double> new_goal = local_fifo.front();

    move_base_msgs::MoveBaseGoal goal;
    goal.target_pose.header.frame_id = goal_frame_;
    goal.target_pose.header.stamp = ros::Time::now();
    goal.target_pose.pose.position.x = std::get<0>(new_goal);
    goal.target_pose.pose.position.y = std::get<1>(new_goal);
    goal.target_pose.pose.position.z = 0.0;
    goal.target_pose.pose.orientation.w = 1.0;
    goal.target_pose.pose.orientation.x = 0.0;
    goal.target_pose.pose.orientation.y = 0.0;
    goal.target_pose.pose.orientation.z = 0.0;
    
    action_client_->sendGoal(goal);
    ROS_INFO("[%s]: SENT GOAL -> [%f, %f]", node_name_.c_str(), std::get<0>(new_goal), std::get<1>(new_goal));
    */
  } 

  

  else if(move_status==6) {

    /*
    uint8 PREEMPTING      = 6   # The goal received a cancel request after it started executing
                                #    and has not yet completed execution
    >>>>>>> strategy: pursue next goal
    */

    /*
    action_client_->cancelAllGoals();
    std::pair<double,double> succeeded_goal_temp = local_fifo.front();
    ROS_INFO("[%s]: CANCELLED PREEMPTING GOAL AT: [%f,%f]", node_name_.c_str(), std::get<0>(succeeded_goal_temp),std::get<1>(succeeded_goal_temp));

    // Get and publish the succeeded_goal
    succeeded_goal.pose.position.x = std::get<0>(succeeded_goal_temp);
    succeeded_goal.pose.position.y = std::get<1>(succeeded_goal_temp);
    succeeded_goal_pub.publish(succeeded_goal);

    // Delete succeeded_goal from local_fifo
    local_fifo.pop();
    ROS_INFO("[%s]: PUBLISHED + DELETED SUCCEEDED GOAL", node_name_.c_str());

    std::pair<double,double> new_goal = local_fifo.front();

    move_base_msgs::MoveBaseGoal goal;
    goal.target_pose.header.frame_id = goal_frame_;
    goal.target_pose.header.stamp = ros::Time::now();
    goal.target_pose.pose.position.x = std::get<0>(new_goal);
    goal.target_pose.pose.position.y = std::get<1>(new_goal);
    goal.target_pose.pose.position.z = 0.0;
    goal.target_pose.pose.orientation.w = 1.0;
    goal.target_pose.pose.orientation.x = 0.0;
    goal.target_pose.pose.orientation.y = 0.0;
    goal.target_pose.pose.orientation.z = 0.0;
    
    action_client_->sendGoal(goal);
    ROS_INFO("[%s]: SENT GOAL -> [%f, %f]", node_name_.c_str(), std::get<0>(new_goal), std::get<1>(new_goal));
    */
  
  }
  

  if(move_status == 7 || move_status==8 || move_status==9) {

    /*
    uint8 RECALLING       = 7   # The goal received a cancel request before it started executing,
                                #    but the action server has not yet confirmed that the goal is canceled
    >>>>>>> next goal

    uint8 RECALLED        = 8   # The goal received a cancel request before it started executing
                                #    and was successfully cancelled (Terminal State)
    >>>>>>> next goal

    uint8 LOST            = 9   # An action client can determine that a goal is LOST. This should not be
                                #    sent over the wire by an action server
    >>>>>>> next goal
    */

    /*
    action_client_->cancelAllGoals();
    
    // Get current goal
    std::pair<double,double> succeeded_goal_temp = local_fifo.front();
    succeeded_goal.pose.position.x = std::get<0>(succeeded_goal_temp);
    succeeded_goal.pose.position.x = std::get<1>(succeeded_goal_temp);
    ROS_INFO("[%s]: ABORTED CURRENT GOAL: [%f,%f]", node_name_.c_str(), succeeded_goal.pose.position.x, succeeded_goal.pose.position.y);

    // Publish succeeded_goal
    succeeded_goal_pub.publish(succeeded_goal);

    // Delete succeeded_goal from local_fifo
    local_fifo.pop();
    ROS_INFO("[%s]: PUBLISHED + DELETED SUCCEEDED GOAL", node_name_.c_str());

    std::pair<double,double> new_goal = local_fifo.front();

    move_base_msgs::MoveBaseGoal goal;
    goal.target_pose.header.frame_id = goal_frame_;
    goal.target_pose.header.stamp = ros::Time::now();
    goal.target_pose.pose.position.x = std::get<0>(new_goal);
    goal.target_pose.pose.position.y = std::get<1>(new_goal);
    goal.target_pose.pose.position.z = 0.0;
    goal.target_pose.pose.orientation.w = 1.0;
    goal.target_pose.pose.orientation.x = 0.0;
    goal.target_pose.pose.orientation.y = 0.0;
    goal.target_pose.pose.orientation.z = 0.0;
    
    action_client_->sendGoal(goal);
    ROS_INFO("[%s]: SENT GOAL -> [%f, %f]", node_name_.c_str(), std::get<0>(new_goal), std::get<1>(new_goal));
    */
  }  
         
} //end HandleMoveBaseReaction()



void LocalManager::spin() {

    // run at 3Hz
    // can be varied but might change the smoothness
    // of the local_traverse-following behavior
    ros::Rate r(3.0);
    while (ros::ok())
    {
      
      ros::spinOnce(); // get callback inputs
      
      pursueLocalGoals(); // run according to currently known information

      HandleMoveBaseReaction(); //react to move_base and generate publications

      // checkSigShutdown();
        
      r.sleep();
    }
    end_status_publisher_.publish(true);
}

int main(int argc, char **argv)
{
  // initialize node
  ros::init(argc, argv, "local_manager");

  // call constructor
  LocalManager LocalManager;

  // start subscription and initialize callback functions
  // start publications
  LocalManager.SubscribeToTopics();
  LocalManager.PublishSucceededLocalGoal();

  // enter continuous f
  LocalManager.spin();
  return 0;
}
  
// PROCESS AMCL POSE INFORMATION
void LocalManager::robotPoseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg)
{
  robot_pose = *msg;
	robot_pos_x = robot_pose.pose.pose.position.x;
	robot_pos_y = robot_pose.pose.pose.position.y;

  //ROS_INFO("[%s]: ROBOT-POS [%f,%f]", node_name_.c_str(), robot_pos_x, robot_pos_y);
}

// PROCESS MOVE BASE RESULT INFORMATION
void LocalManager::moveBaseResultCallback(const move_base_msgs::MoveBaseActionResult::ConstPtr& msg)
{
  //ROS_INFO("Received result from move_base");
  move_base_result = *msg;
}

// PROCESS LOCAL_PATH_PLANNER INFORMATION
void LocalManager::localTraverseCallback(const geometry_msgs::PoseArray::ConstPtr& msg)
{
  local_traverse = *msg;
  // when receiving a new local_traverse, cancel the current goals and generate a new traverse
  // this ensures real-time capability
  action_client_->cancelAllGoals();

  // We receive a new traverse of specified size
  int local_traverse_length;
  local_traverse_length = local_traverse.poses.size();
  ROS_INFO("[%s]: NEW local_traverse OF LENGTH %i RECEIVED", node_name_.c_str(), local_traverse_length);

  if (local_fifo.size()!=0) {
    //ROS_INFO("[%s]: CLEARING OLD local_fifo...", node_name_.c_str());
  }

  // initialize a local, temporary defined deque
  std::deque<std::pair<double,double>> local_fifo_temp;

  // feed our temporary deque with new local_traverse received from local_path_planner
	for (int i = 0; i < local_traverse.poses.size(); ++i)
	{
		std::pair<double,double> coord = {local_traverse.poses[i].position.x,local_traverse.poses[i].position.y};
		local_fifo_temp.push_back(coord);
    //ROS_INFO("[%s]: GOAL ADDED [%f, %f]", node_name_.c_str(), std::get<0>(coord), std::get<1>(coord));
	}
  // make globally-defined fifo take the info of the temporary fifo
  local_fifo = local_fifo_temp;

  // print out new fifo
  ROS_INFO("[%s]: NEW local_fifo:", node_name_.c_str());
  for (int i = 0; i < local_traverse.poses.size(); ++i)
	{
		
    ROS_INFO("[%s]: [%f, %f]", node_name_.c_str(), local_traverse.poses[i].position.x, local_traverse.poses[i].position.y);
	}
  //ROS_INFO("[%s]: local_fifo OF SIZE %lu GENERATED", node_name_.c_str(), local_fifo.size());
}

// PROCESS PSEUDO TRAVERSE INFORMATION FROM DIRT-GENERATOR
void LocalManager::pseudoGoalListCallback(const goal_list::GoalObjectList::ConstPtr& msg)
{
  pseudo_goal_list = *msg;

  // We receive a new traverse of specified size
  int pseudo_traverse_length;
  pseudo_traverse_length = local_traverse.poses.size();
  //ROS_INFO("[%s]: NEW local_traverse OF LENGTH %i RECEIVED", node_name_.c_str(), local_traverse_length);

  // initialize a local, temporary defined deque
  std::deque<std::pair<double,double>> pseudo_fifo_temp;

  // feed our temporary deque with new local_traverse received from local_path_planner
	for (int i = 0; i < pseudo_goal_list.goal_list.size(); ++i)
	{
		std::pair<double,double> coord = {pseudo_goal_list.goal_list[i].pose.position.x, pseudo_goal_list.goal_list[i].pose.position.y};
		pseudo_fifo_temp.push_back(coord);
    //ROS_INFO("[%s]: GOAL ADDED [%f, %f]", node_name_.c_str(), std::get<0>(coord), std::get<1>(coord));
	}

  // set next pseudo goal
  latest_pseudo_goal_new = pseudo_fifo_temp.front();

  // check if this is the first callback ever received since starting the node
  if(initial_counter==0) {
    // SET INITIAL latest GOAL
    latest_pseudo_goal = latest_pseudo_goal_new;
    initial_counter=1;
  }
  else {
    // NOT FIRST RECEPTION OF PSEUDO GOAL LIST ANYMORE
  }
 // make globally-defined fifo take the info of the temporary
  pseudo_fifo = pseudo_fifo_temp;


  //ROS_INFO("[%s]: NEW pseudo_fifo:", node_name_.c_str());
  for (int i = 0; i < pseudo_goal_list.goal_list.size(); ++i)
	{
		
    //ROS_INFO("[%s]: [%f, %f]", node_name_.c_str(), pseudo_goal_list.goal_list[i].pose.position.x, pseudo_goal_list.goal_list[i].pose.position.y);
	}
  //ROS_INFO("[%s]: pseudo_fifo OF SIZE %lu GENERATED", node_name_.c_str(), pseudo_fifo.size());
}